// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: 'https://api-lucid-dev.daydreams.systems' | (string & {});
};

export type SerializedEntrypoint = {
    /**
     * Unique identifier for this entrypoint
     */
    key: string;
    /**
     * Human-readable description
     */
    description?: string;
    /**
     * JSON Schema for input validation (empty = accept any)
     */
    inputSchema?: {
        [key: string]: unknown;
    };
    /**
     * JSON Schema for output validation (empty = accept any)
     */
    outputSchema?: {
        [key: string]: unknown;
    };
    /**
     * Type of handler (builtin, js, url, llm, graph, webhook). Defaults to builtin.
     */
    handlerType?: 'builtin' | 'js' | 'url' | 'llm' | 'graph' | 'webhook';
    /**
     * Configuration for the handler
     */
    handlerConfig: {
        name: string;
        [key: string]: unknown | string;
    } | {
        /**
         * Inline JavaScript to execute
         */
        code: string;
        /**
         * Execution timeout override in milliseconds
         */
        timeoutMs?: number;
        /**
         * Optional network allowlist for fetch
         */
        network?: {
            /**
             * Allow-listed hosts for outbound fetch
             */
            allowedHosts: Array<string>;
            /**
             * Network request timeout in milliseconds
             */
            timeoutMs?: number;
        };
        [key: string]: unknown | string | number | {
            /**
             * Allow-listed hosts for outbound fetch
             */
            allowedHosts: Array<string>;
            /**
             * Network request timeout in milliseconds
             */
            timeoutMs?: number;
        } | undefined;
    } | {
        /**
         * Absolute URL to fetch
         */
        url: string;
        /**
         * HTTP method to use
         */
        method?: 'GET' | 'POST';
        /**
         * Headers to include in the request
         */
        headers?: {
            [key: string]: string;
        };
        /**
         * Optional JSON-serializable body (for POST)
         */
        body?: unknown;
        /**
         * Request timeout in milliseconds
         */
        timeoutMs?: number;
        /**
         * Allow-listed hosts for outbound fetch. Use ["*"] to allow any host (not recommended).
         */
        allowedHosts: Array<string>;
        [key: string]: unknown | string | 'GET' | 'POST' | {
            [key: string]: string;
        } | number | Array<string> | undefined;
    } | {
        [key: string]: unknown;
    };
    /**
     * Price in base units (smallest denomination). Must match the token's smallest denomination (e.g., "1000" = $0.001 USDC).
     */
    price?: string;
    /**
     * Payment network override for this entrypoint (defaults to agent paymentsConfig.network)
     */
    network?: string;
    /**
     * Additional metadata
     */
    metadata?: {
        [key: string]: unknown;
    };
};

/**
 * Payment storage configuration (for analytics). Defaults to SQLite if not specified.
 */
export type PaymentStorageConfig = {
    /**
     * Storage backend type. SQLite is automatic (no configuration needed). Postgres requires a connection string.
     */
    type: 'sqlite' | 'postgres';
    postgres?: {
        /**
         * PostgreSQL connection string (required when type is postgres)
         */
        connectionString: string;
    };
};

/**
 * Payment configuration for monetizing entrypoints
 */
export type PaymentsConfig = {
    /**
     * Wallet address to receive payments
     */
    payTo: string;
    /**
     * Payment network (e.g., base-sepolia, base)
     */
    network: string;
    /**
     * URL of the x402 facilitator service
     */
    facilitatorUrl: string;
    storage?: PaymentStorageConfig;
};

/**
 * Wallet configuration for agent to make payments
 */
export type WalletsConfig = {
    /**
     * Agent wallet configuration for making payments
     */
    agent?: {
        /**
         * Wallet type
         */
        type: 'local' | 'thirdweb' | 'signer';
        /**
         * Private key for local wallet (required for type: local)
         */
        privateKey?: string;
        /**
         * Thirdweb secret key (for type: thirdweb)
         */
        secretKey?: string;
        /**
         * Thirdweb client ID (for type: thirdweb)
         */
        clientId?: string;
        /**
         * Wallet label (for type: thirdweb)
         */
        walletLabel?: string;
        /**
         * Chain ID (for type: thirdweb)
         */
        chainId?: number;
    };
};

/**
 * Agent-to-agent protocol configuration
 */
export type A2aConfig = {
    /**
     * Whether A2A protocol is enabled for this agent
     */
    enabled?: boolean;
};

/**
 * AP2 (Agent Payments Protocol) configuration
 */
export type Ap2Config = {
    /**
     * AP2 payment roles this agent supports
     */
    roles: Array<'merchant' | 'shopper' | 'credentials-provider' | 'payment-processor'>;
    /**
     * Optional description of AP2 capabilities
     */
    description?: string;
    /**
     * Whether AP2 payment is required for this agent
     */
    required?: boolean;
};

/**
 * Analytics configuration (requires payments to be enabled)
 */
export type AnalyticsConfig = {
    /**
     * Whether analytics tracking is enabled (requires payments)
     */
    enabled?: boolean;
};

/**
 * ERC-8004 identity configuration (requires wallet to be configured)
 */
export type IdentityConfig = {
    /**
     * Chain ID for ERC-8004 registry (defaults to Base Sepolia: 84532)
     */
    chainId?: number;
    /**
     * RPC URL for blockchain connection
     */
    rpcUrl?: string;
    /**
     * ERC-8004 registry contract address (optional, falls back to env/default)
     */
    registryAddress?: string;
    /**
     * Whether to automatically register identity if not found
     */
    autoRegister?: boolean;
    /**
     * Trust models to advertise (e.g., feedback, inference-validation, tee-attestation)
     */
    trustModels?: Array<string>;
    /**
     * Optional custom trust config overrides (off-chain mirrors)
     */
    trustOverrides?: {
        /**
         * URL for validation requests mirror
         */
        validationRequestsUri?: string;
        /**
         * URL for validation responses mirror
         */
        validationResponsesUri?: string;
        /**
         * URL for feedback data mirror
         */
        feedbackDataUri?: string;
    };
};

export type CreateAgent = {
    /**
     * URL-friendly unique identifier
     */
    slug: string;
    /**
     * Human-readable name
     */
    name: string;
    /**
     * Human-readable description
     */
    description?: string;
    /**
     * At least one entrypoint is required
     */
    entrypoints: Array<SerializedEntrypoint>;
    /**
     * Whether the agent can be invoked
     */
    enabled?: boolean;
    /**
     * Additional metadata
     */
    metadata?: {
        [key: string]: unknown;
    };
    paymentsConfig?: PaymentsConfig;
    walletsConfig?: WalletsConfig;
    a2aConfig?: A2aConfig;
    ap2Config?: Ap2Config;
    analyticsConfig?: AnalyticsConfig;
    identityConfig?: IdentityConfig;
    /**
     * Whether the one-time setup fee has been paid (for agents with paid endpoints)
     */
    paidSetupFee?: boolean;
};

export type AgentDefinition = CreateAgent & {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Owner identifier
     */
    ownerId: string;
    /**
     * Agent version
     */
    version: string;
    createdAt: string;
    updatedAt: string;
};

export type AgentListResponse = {
    agents: Array<AgentDefinition>;
    total: number;
    offset: number;
    limit: number;
};

export type _Error = {
    error: string;
    code?: string;
    details?: {
        [key: string]: unknown;
    };
};

export type UpdateAgent = {
    /**
     * URL-friendly unique identifier
     */
    slug?: string;
    /**
     * Human-readable name
     */
    name?: string;
    /**
     * Human-readable description
     */
    description?: string;
    /**
     * At least one entrypoint is required
     */
    entrypoints?: Array<SerializedEntrypoint>;
    /**
     * Whether the agent can be invoked
     */
    enabled?: boolean;
    /**
     * Additional metadata
     */
    metadata?: {
        [key: string]: unknown;
    };
    paymentsConfig?: PaymentsConfig;
    walletsConfig?: WalletsConfig;
    a2aConfig?: A2aConfig;
    ap2Config?: Ap2Config;
    analyticsConfig?: AnalyticsConfig;
    identityConfig?: IdentityConfig;
    /**
     * Whether the one-time setup fee has been paid (for agents with paid endpoints)
     */
    paidSetupFee?: boolean;
};

export type SecretMetadata = {
    /**
     * Unique secret identifier
     */
    id: string;
    /**
     * Agent this secret belongs to
     */
    agentId: string;
    /**
     * Unique name for this secret (1-64 lowercase alphanumeric chars with hyphens)
     */
    name: string;
    /**
     * Encryption key version (for rotation)
     */
    keyVersion: number;
    createdAt: string;
    updatedAt: string;
};

export type SecretListResponse = {
    secrets: Array<SecretMetadata>;
};

export type CreateSecret = {
    /**
     * Unique name for this secret (1-64 lowercase alphanumeric chars with hyphens)
     */
    name: string;
    /**
     * The secret value (will be encrypted at rest)
     */
    value: string;
};

export type UpdateSecret = {
    /**
     * The new secret value
     */
    value: string;
};

export type AgentManifest = {
    protocolVersion?: string;
    name: string;
    description?: string;
    /**
     * Canonical URL of the agent
     */
    url?: string;
    supportedInterfaces?: Array<{
        url: string;
        protocolBinding: string;
    }>;
    provider?: {
        organization?: string;
        url?: string;
    };
    version?: string;
    documentationUrl?: string;
    capabilities?: {
        streaming?: boolean;
        pushNotifications?: boolean;
        stateTransitionHistory?: boolean;
        extensions?: Array<{
            [key: string]: unknown;
        }>;
    };
    securitySchemes?: {
        [key: string]: unknown;
    };
    security?: Array<unknown>;
    defaultInputModes?: Array<string>;
    defaultOutputModes?: Array<string>;
    skills?: Array<{
        id: string;
        name?: string;
        description?: string;
        tags?: Array<string>;
        examples?: Array<string>;
        inputModes?: Array<string>;
        outputModes?: Array<string>;
        security?: Array<unknown>;
    }>;
    supportsAuthenticatedExtendedCard?: boolean;
    signatures?: Array<{
        protected: string;
        signature: string;
        header?: {
            [key: string]: unknown;
        };
    }>;
    iconUrl?: string;
    payments?: Array<{
        [key: string]: unknown;
    }>;
    registrations?: Array<{
        [key: string]: unknown;
    }>;
    trustModels?: Array<string>;
    ValidationRequestsURI?: string;
    ValidationResponsesURI?: string;
    FeedbackDataURI?: string;
    /**
     * Entrypoint definitions keyed by skill id
     */
    entrypoints: {
        [key: string]: {
            description?: string;
            streaming: boolean;
            input_schema?: unknown;
            output_schema?: unknown;
            pricing?: {
                invoke?: string;
                stream?: string;
            };
            [key: string]: unknown | string | boolean | {
                invoke?: string;
                stream?: string;
            } | undefined;
        };
    };
    [key: string]: unknown | string | Array<{
        url: string;
        protocolBinding: string;
    }> | {
        organization?: string;
        url?: string;
    } | {
        streaming?: boolean;
        pushNotifications?: boolean;
        stateTransitionHistory?: boolean;
        extensions?: Array<{
            [key: string]: unknown;
        }>;
    } | {
        [key: string]: unknown;
    } | Array<unknown> | Array<string> | Array<string> | Array<{
        id: string;
        name?: string;
        description?: string;
        tags?: Array<string>;
        examples?: Array<string>;
        inputModes?: Array<string>;
        outputModes?: Array<string>;
        security?: Array<unknown>;
    }> | boolean | Array<{
        protected: string;
        signature: string;
        header?: {
            [key: string]: unknown;
        };
    }> | Array<{
        [key: string]: unknown;
    }> | Array<{
        [key: string]: unknown;
    }> | Array<string> | {
        [key: string]: {
            description?: string;
            streaming: boolean;
            input_schema?: unknown;
            output_schema?: unknown;
            pricing?: {
                invoke?: string;
                stream?: string;
            };
            [key: string]: unknown | string | boolean | {
                invoke?: string;
                stream?: string;
            } | undefined;
        };
    } | undefined;
};

export type Usage = {
    total_tokens?: number;
    prompt_tokens?: number;
    completion_tokens?: number;
};

export type InvokeResponse = {
    /**
     * Output from the entrypoint handler
     */
    output?: unknown;
    usage?: Usage;
    /**
     * Session ID used for this invocation
     */
    sessionId: string;
    /**
     * Unique request identifier
     */
    requestId: string;
};

export type PaymentAccept = {
    /**
     * Payment scheme type
     */
    scheme: string;
    /**
     * Price in human-readable format
     */
    price: string;
    /**
     * Network identifier (EIP-155 chain ID or Solana cluster)
     */
    network: string;
    /**
     * Recipient address for payment
     */
    payTo: string;
};

export type PaymentRequired = {
    /**
     * Error message
     */
    error: string;
    /**
     * Error code
     */
    code: 'PAYMENT_REQUIRED';
    /**
     * Accepted payment options
     */
    accepts: Array<PaymentAccept>;
    /**
     * Description of the paid resource
     */
    description?: string;
    /**
     * URL of the x402 facilitator service
     */
    facilitatorUrl?: string;
};

export type InvokeRequest = {
    /**
     * Input payload for the entrypoint
     */
    input?: unknown;
    /**
     * Session ID for conversation continuity
     */
    sessionId?: string;
    /**
     * Additional metadata for the invocation
     */
    metadata?: {
        [key: string]: unknown;
    };
};

export type AnalyticsSummary = {
    /**
     * Total outgoing payments in base units (6 decimals)
     */
    outgoingTotal: string;
    /**
     * Total incoming payments in base units (6 decimals)
     */
    incomingTotal: string;
    /**
     * Net total (incoming - outgoing) in base units
     */
    netTotal: string;
    /**
     * Number of outgoing transactions
     */
    outgoingCount: number;
    /**
     * Number of incoming transactions
     */
    incomingCount: number;
    /**
     * Start of time window in milliseconds (null if all time)
     */
    windowStart?: number | null;
    /**
     * End of time window in milliseconds
     */
    windowEnd: number;
};

export type Transaction = {
    /**
     * Transaction ID
     */
    id?: string;
    /**
     * Transaction group name
     */
    groupName: string;
    /**
     * Transaction scope
     */
    scope: string;
    /**
     * Payment direction
     */
    direction: 'incoming' | 'outgoing';
    /**
     * Amount in base units (6 decimals)
     */
    amount: string;
    /**
     * Amount in USDC (formatted)
     */
    amountUsdc: string;
    /**
     * Timestamp in milliseconds
     */
    timestamp: number;
    /**
     * ISO timestamp string
     */
    timestampIso: string;
};

export type IdentityRegistrationResult = {
    /**
     * Registration status
     */
    status: 'registered' | 'pending' | 'failed' | 'not_registered';
    /**
     * ERC-8004 agent ID (if registered)
     */
    agentId?: string;
    /**
     * Owner address (if registered)
     */
    owner?: string;
    /**
     * Agent URI (if registered)
     */
    agentURI?: string;
    /**
     * Agent domain used for registration
     */
    domain?: string;
    /**
     * Error message (if failed)
     */
    error?: string;
};

export type UpdateIdentityMetadataRequest = {
    /**
     * Whether registration was successful
     */
    didRegister: boolean;
    /**
     * Identity record from on-chain registration
     */
    record?: {
        agentId?: string | number | string;
        owner?: string;
        agentURI?: string;
    };
    /**
     * Transaction hash (if registered)
     */
    transactionHash?: string;
    /**
     * Human-readable status message
     */
    status?: string;
    /**
     * Agent domain used for registration
     */
    domain?: string;
};

export type Health = {
    /**
     * Health status: ok, degraded, or down
     */
    status: string;
    version?: string;
    timestamp: string;
};

export type RedisMemoryUsage = {
    /**
     * Used memory in bytes
     */
    used: number;
    /**
     * Peak memory usage in bytes
     */
    peak: number;
    /**
     * Total system memory in bytes
     */
    total: number;
};

export type RedisHealth = {
    /**
     * Redis connection status
     */
    status: 'disconnected' | 'connecting' | 'connected' | 'reconnecting' | 'error' | 'end';
    connected: boolean;
    /**
     * Ping latency in milliseconds
     */
    latencyMs?: number;
    /**
     * Last error message
     */
    lastError?: string;
    /**
     * Timestamp of last error
     */
    lastErrorAt?: string;
    /**
     * Connection uptime in milliseconds
     */
    uptime?: number;
    memoryUsage?: RedisMemoryUsage;
    /**
     * Number of connected Redis clients
     */
    connectedClients?: number;
    /**
     * Approximate number of keys in the database
     */
    keyCount?: number;
};

export type NetworkStats = {
    /**
     * Total number of registered agents
     */
    agentCount: number;
    /**
     * Total number of endpoints across all agents
     */
    endpointCount: number;
    /**
     * Total number of invocations
     */
    invocationCount: number;
    /**
     * Total revenue volume in USD
     */
    totalVolume: string;
};

export type RankingEntry = {
    key: string;
    /**
     * Primary ranking score
     */
    score: number;
    agentId: string;
    agentName: string;
    entrypointKey: string;
    entrypointDescription?: string;
    callCount: number;
    successCount: number;
    errorCount: number;
    /**
     * Revenue in decimal string
     */
    totalRevenue: string;
    /**
     * Average latency in milliseconds
     */
    avgLatencyMs: number;
    /**
     * Score in previous window
     */
    previousScore: number;
    /**
     * Percentage change from previous window
     */
    velocity: number;
    /**
     * Trend direction
     */
    trend: 'up' | 'down' | 'stable';
    lastInvocationAt: string;
};

export type RankingResult = {
    query: {
        /**
         * Metric to rank by
         */
        metric: 'calls' | 'revenue' | 'errors' | 'latency' | 'trending';
        /**
         * Time window for ranking
         */
        window: '1m' | '5m' | '15m' | '1h' | '24h' | '7d';
        /**
         * Ranking scope
         */
        scope: 'global' | 'owner' | 'agent';
        scopeId?: string;
        limit: number;
        offset?: number;
    };
    rankings: Array<RankingEntry>;
    /**
     * Total ranked endpoints
     */
    total: number;
    updatedAt: string;
    /**
     * Milliseconds until next refresh
     */
    nextUpdateIn: number;
};

export type Invocation = {
    id: string;
    agentId: string;
    agentName: string;
    ownerId: string;
    entrypointKey: string;
    entrypointDescription: string | null;
    /**
     * Execution status of the invocation
     */
    status: 'success' | 'error' | 'timeout';
    executionTimeMs: number;
    errorMessage: string | null;
    errorCode: string | null;
    paymentAmount: string | null;
    paymentNetwork: string | null;
    paymentTxHash: string | null;
    requestHash: string | null;
    responseSize: number | null;
    tokensInput: number | null;
    tokensOutput: number | null;
    callerIp: string | null;
    callerUserAgent: string | null;
    startedAt: string;
    completedAt: string;
    createdAt: string;
};

export type InvocationListResult = {
    invocations: Array<Invocation>;
    /**
     * Total count matching query
     */
    total: number;
    query: {
        /**
         * Filter by agent ID
         */
        agentId?: string;
        /**
         * Filter by entrypoint key
         */
        entrypointKey?: string;
        /**
         * Filter by status
         */
        status?: 'success' | 'error' | 'timeout';
        /**
         * Start of time range (inclusive)
         */
        startDate?: string;
        /**
         * End of time range (inclusive)
         */
        endDate?: string;
        /**
         * Number of items to skip
         */
        offset?: number | null;
        /**
         * Maximum items to return
         */
        limit?: number;
    };
};

export type InvocationStats = {
    /**
     * Total invocation count
     */
    totalCount: number;
    /**
     * Successful invocations
     */
    successCount: number;
    /**
     * Failed invocations
     */
    errorCount: number;
    /**
     * Success rate as percentage
     */
    successRate: number;
    /**
     * Total revenue
     */
    totalRevenue: string;
    /**
     * Average execution time
     */
    avgExecutionTimeMs: number;
    /**
     * Total input tokens
     */
    totalTokensInput: number;
    /**
     * Total output tokens
     */
    totalTokensOutput: number;
};

export type InvocationTimeSeriesPoint = {
    /**
     * Start of time bucket
     */
    bucket: string;
    totalCount: number;
    successCount: number;
    errorCount: number;
    totalRevenue: string;
    avgExecutionTimeMs: number;
};

export type InvocationTimeSeriesResult = Array<InvocationTimeSeriesPoint>;

export type GetApiAgentsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Number of items to skip
         */
        offset?: number | null;
        /**
         * Maximum number of items to return
         */
        limit?: number;
        /**
         * Search agents by name, slug, or description
         */
        search?: string;
        /**
         * Filter by enabled status
         */
        enabled?: 'true' | 'false';
    };
    url: '/api/agents';
};

export type GetApiAgentsResponses = {
    /**
     * List of agents
     */
    200: AgentListResponse;
};

export type GetApiAgentsResponse = GetApiAgentsResponses[keyof GetApiAgentsResponses];

export type PostApiAgentsData = {
    body: CreateAgent;
    path?: never;
    query?: never;
    url: '/api/agents';
};

export type PostApiAgentsErrors = {
    /**
     * Validation error
     */
    400: _Error;
    /**
     * Slug already exists
     */
    409: _Error;
};

export type PostApiAgentsError = PostApiAgentsErrors[keyof PostApiAgentsErrors];

export type PostApiAgentsResponses = {
    /**
     * Agent created successfully
     */
    201: AgentDefinition;
};

export type PostApiAgentsResponse = PostApiAgentsResponses[keyof PostApiAgentsResponses];

export type DeleteApiAgentsByAgentIdData = {
    body?: never;
    path: {
        agentId: string;
    };
    query?: never;
    url: '/api/agents/{agentId}';
};

export type DeleteApiAgentsByAgentIdErrors = {
    /**
     * Agent not found
     */
    404: _Error;
};

export type DeleteApiAgentsByAgentIdError = DeleteApiAgentsByAgentIdErrors[keyof DeleteApiAgentsByAgentIdErrors];

export type DeleteApiAgentsByAgentIdResponses = {
    /**
     * Agent deleted successfully
     */
    204: void;
};

export type DeleteApiAgentsByAgentIdResponse = DeleteApiAgentsByAgentIdResponses[keyof DeleteApiAgentsByAgentIdResponses];

export type GetApiAgentsByAgentIdData = {
    body?: never;
    path: {
        agentId: string;
    };
    query?: never;
    url: '/api/agents/{agentId}';
};

export type GetApiAgentsByAgentIdErrors = {
    /**
     * Agent not found
     */
    404: _Error;
};

export type GetApiAgentsByAgentIdError = GetApiAgentsByAgentIdErrors[keyof GetApiAgentsByAgentIdErrors];

export type GetApiAgentsByAgentIdResponses = {
    /**
     * Agent definition
     */
    200: AgentDefinition;
};

export type GetApiAgentsByAgentIdResponse = GetApiAgentsByAgentIdResponses[keyof GetApiAgentsByAgentIdResponses];

export type PutApiAgentsByAgentIdData = {
    body: UpdateAgent;
    path: {
        agentId: string;
    };
    query?: never;
    url: '/api/agents/{agentId}';
};

export type PutApiAgentsByAgentIdErrors = {
    /**
     * Agent not found
     */
    404: _Error;
    /**
     * Slug already exists
     */
    409: _Error;
};

export type PutApiAgentsByAgentIdError = PutApiAgentsByAgentIdErrors[keyof PutApiAgentsByAgentIdErrors];

export type PutApiAgentsByAgentIdResponses = {
    /**
     * Agent updated successfully
     */
    200: AgentDefinition;
};

export type PutApiAgentsByAgentIdResponse = PutApiAgentsByAgentIdResponses[keyof PutApiAgentsByAgentIdResponses];

export type PostApiAgentsSetupPaymentData = {
    body: {
        /**
         * Slug of the agent for this setup payment
         */
        slug: string;
        /**
         * Payment network for the setup fee
         */
        network: string;
    };
    path?: never;
    query?: never;
    url: '/api/agents/setup-payment';
};

export type PostApiAgentsSetupPaymentErrors = {
    /**
     * Payment required - includes X402 v2 payment details in PAYMENT-REQUIRED header
     */
    402: _Error;
};

export type PostApiAgentsSetupPaymentError = PostApiAgentsSetupPaymentErrors[keyof PostApiAgentsSetupPaymentErrors];

export type PostApiAgentsSetupPaymentResponses = {
    /**
     * Payment processed successfully
     */
    200: {
        success: boolean;
        message: string;
    };
};

export type PostApiAgentsSetupPaymentResponse = PostApiAgentsSetupPaymentResponses[keyof PostApiAgentsSetupPaymentResponses];

export type GetApiAgentsByAgentIdSecretsData = {
    body?: never;
    path: {
        agentId: string;
    };
    query?: never;
    url: '/api/agents/{agentId}/secrets';
};

export type GetApiAgentsByAgentIdSecretsErrors = {
    /**
     * Agent not found
     */
    404: _Error;
};

export type GetApiAgentsByAgentIdSecretsError = GetApiAgentsByAgentIdSecretsErrors[keyof GetApiAgentsByAgentIdSecretsErrors];

export type GetApiAgentsByAgentIdSecretsResponses = {
    /**
     * List of secret metadata
     */
    200: SecretListResponse;
};

export type GetApiAgentsByAgentIdSecretsResponse = GetApiAgentsByAgentIdSecretsResponses[keyof GetApiAgentsByAgentIdSecretsResponses];

export type PostApiAgentsByAgentIdSecretsData = {
    body: CreateSecret;
    path: {
        agentId: string;
    };
    query?: never;
    url: '/api/agents/{agentId}/secrets';
};

export type PostApiAgentsByAgentIdSecretsErrors = {
    /**
     * Validation error (e.g., invalid secret name)
     */
    400: _Error;
    /**
     * Agent not found
     */
    404: _Error;
    /**
     * Secret with this name already exists
     */
    409: _Error;
};

export type PostApiAgentsByAgentIdSecretsError = PostApiAgentsByAgentIdSecretsErrors[keyof PostApiAgentsByAgentIdSecretsErrors];

export type PostApiAgentsByAgentIdSecretsResponses = {
    /**
     * Secret created successfully
     */
    201: SecretMetadata;
};

export type PostApiAgentsByAgentIdSecretsResponse = PostApiAgentsByAgentIdSecretsResponses[keyof PostApiAgentsByAgentIdSecretsResponses];

export type DeleteApiAgentsByAgentIdSecretsBySecretIdData = {
    body?: never;
    path: {
        agentId: string;
        /**
         * Secret ID
         */
        secretId: string;
    };
    query?: never;
    url: '/api/agents/{agentId}/secrets/{secretId}';
};

export type DeleteApiAgentsByAgentIdSecretsBySecretIdErrors = {
    /**
     * Agent or secret not found
     */
    404: _Error;
};

export type DeleteApiAgentsByAgentIdSecretsBySecretIdError = DeleteApiAgentsByAgentIdSecretsBySecretIdErrors[keyof DeleteApiAgentsByAgentIdSecretsBySecretIdErrors];

export type DeleteApiAgentsByAgentIdSecretsBySecretIdResponses = {
    /**
     * Secret deleted successfully
     */
    204: void;
};

export type DeleteApiAgentsByAgentIdSecretsBySecretIdResponse = DeleteApiAgentsByAgentIdSecretsBySecretIdResponses[keyof DeleteApiAgentsByAgentIdSecretsBySecretIdResponses];

export type GetApiAgentsByAgentIdSecretsBySecretIdData = {
    body?: never;
    path: {
        agentId: string;
        /**
         * Secret ID
         */
        secretId: string;
    };
    query?: never;
    url: '/api/agents/{agentId}/secrets/{secretId}';
};

export type GetApiAgentsByAgentIdSecretsBySecretIdErrors = {
    /**
     * Agent or secret not found
     */
    404: _Error;
};

export type GetApiAgentsByAgentIdSecretsBySecretIdError = GetApiAgentsByAgentIdSecretsBySecretIdErrors[keyof GetApiAgentsByAgentIdSecretsBySecretIdErrors];

export type GetApiAgentsByAgentIdSecretsBySecretIdResponses = {
    /**
     * Secret metadata
     */
    200: SecretMetadata;
};

export type GetApiAgentsByAgentIdSecretsBySecretIdResponse = GetApiAgentsByAgentIdSecretsBySecretIdResponses[keyof GetApiAgentsByAgentIdSecretsBySecretIdResponses];

export type PatchApiAgentsByAgentIdSecretsBySecretIdData = {
    body: UpdateSecret;
    path: {
        agentId: string;
        /**
         * Secret ID
         */
        secretId: string;
    };
    query?: never;
    url: '/api/agents/{agentId}/secrets/{secretId}';
};

export type PatchApiAgentsByAgentIdSecretsBySecretIdErrors = {
    /**
     * Agent or secret not found
     */
    404: _Error;
};

export type PatchApiAgentsByAgentIdSecretsBySecretIdError = PatchApiAgentsByAgentIdSecretsBySecretIdErrors[keyof PatchApiAgentsByAgentIdSecretsBySecretIdErrors];

export type PatchApiAgentsByAgentIdSecretsBySecretIdResponses = {
    /**
     * Secret updated successfully
     */
    200: SecretMetadata;
};

export type PatchApiAgentsByAgentIdSecretsBySecretIdResponse = PatchApiAgentsByAgentIdSecretsBySecretIdResponses[keyof PatchApiAgentsByAgentIdSecretsBySecretIdResponses];

export type GetAgentBySlugData = {
    body?: never;
    path: {
        /**
         * URL-friendly agent identifier
         */
        slug: string;
    };
    query?: never;
    url: '/agent/{slug}';
};

export type GetAgentBySlugErrors = {
    /**
     * Agent not found or disabled
     */
    404: _Error;
};

export type GetAgentBySlugError = GetAgentBySlugErrors[keyof GetAgentBySlugErrors];

export type GetAgentBySlugResponses = {
    /**
     * Agent found
     */
    200: AgentDefinition;
};

export type GetAgentBySlugResponse = GetAgentBySlugResponses[keyof GetAgentBySlugResponses];

export type GetAgentsDiscoverData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Offset for pagination
         */
        offset?: number | null;
        /**
         * Maximum number of agents to return
         */
        limit?: number;
        /**
         * Search agents by name, slug, or description
         */
        search?: string;
    };
    url: '/agents/discover';
};

export type GetAgentsDiscoverResponses = {
    /**
     * List of public agents
     */
    200: AgentListResponse;
};

export type GetAgentsDiscoverResponse = GetAgentsDiscoverResponses[keyof GetAgentsDiscoverResponses];

export type GetAgentsByAgentIdWellKnownAgentCardJsonData = {
    body?: never;
    path: {
        agentId: string;
    };
    query?: never;
    url: '/agents/{agentId}/.well-known/agent-card.json';
};

export type GetAgentsByAgentIdWellKnownAgentCardJsonErrors = {
    /**
     * Agent not found
     */
    404: _Error;
};

export type GetAgentsByAgentIdWellKnownAgentCardJsonError = GetAgentsByAgentIdWellKnownAgentCardJsonErrors[keyof GetAgentsByAgentIdWellKnownAgentCardJsonErrors];

export type GetAgentsByAgentIdWellKnownAgentCardJsonResponses = {
    /**
     * Agent manifest
     */
    200: AgentManifest;
};

export type GetAgentsByAgentIdWellKnownAgentCardJsonResponse = GetAgentsByAgentIdWellKnownAgentCardJsonResponses[keyof GetAgentsByAgentIdWellKnownAgentCardJsonResponses];

export type GetAgentsByAgentIdEntrypointsData = {
    body?: never;
    path: {
        agentId: string;
    };
    query?: never;
    url: '/agents/{agentId}/entrypoints';
};

export type GetAgentsByAgentIdEntrypointsErrors = {
    /**
     * Agent not found
     */
    404: _Error;
};

export type GetAgentsByAgentIdEntrypointsError = GetAgentsByAgentIdEntrypointsErrors[keyof GetAgentsByAgentIdEntrypointsErrors];

export type GetAgentsByAgentIdEntrypointsResponses = {
    /**
     * List of entrypoints
     */
    200: Array<SerializedEntrypoint>;
};

export type GetAgentsByAgentIdEntrypointsResponse = GetAgentsByAgentIdEntrypointsResponses[keyof GetAgentsByAgentIdEntrypointsResponses];

export type PostAgentsByAgentIdEntrypointsByKeyInvokeData = {
    body: InvokeRequest;
    path: {
        agentId: string;
        key: string;
    };
    query?: never;
    url: '/agents/{agentId}/entrypoints/{key}/invoke';
};

export type PostAgentsByAgentIdEntrypointsByKeyInvokeErrors = {
    /**
     * Invalid input
     */
    400: _Error;
    /**
     * Payment required. Returns x402 payment details in response body and headers.
     */
    402: PaymentRequired;
    /**
     * Agent or entrypoint not found
     */
    404: _Error;
    /**
     * Internal error during invocation
     */
    500: _Error;
};

export type PostAgentsByAgentIdEntrypointsByKeyInvokeError = PostAgentsByAgentIdEntrypointsByKeyInvokeErrors[keyof PostAgentsByAgentIdEntrypointsByKeyInvokeErrors];

export type PostAgentsByAgentIdEntrypointsByKeyInvokeResponses = {
    /**
     * Invocation successful
     */
    200: InvokeResponse;
};

export type PostAgentsByAgentIdEntrypointsByKeyInvokeResponse = PostAgentsByAgentIdEntrypointsByKeyInvokeResponses[keyof PostAgentsByAgentIdEntrypointsByKeyInvokeResponses];

export type GetApiAgentsByAgentIdAnalyticsSummaryData = {
    body?: never;
    path: {
        agentId: string;
    };
    query?: {
        /**
         * Time window in hours (default: all time)
         */
        windowHours?: number;
        /**
         * Filter by payment direction
         */
        direction?: 'incoming' | 'outgoing';
    };
    url: '/api/agents/{agentId}/analytics/summary';
};

export type GetApiAgentsByAgentIdAnalyticsSummaryErrors = {
    /**
     * Analytics not available (payments not enabled)
     */
    400: _Error;
    /**
     * Agent not found
     */
    404: _Error;
};

export type GetApiAgentsByAgentIdAnalyticsSummaryError = GetApiAgentsByAgentIdAnalyticsSummaryErrors[keyof GetApiAgentsByAgentIdAnalyticsSummaryErrors];

export type GetApiAgentsByAgentIdAnalyticsSummaryResponses = {
    /**
     * Analytics summary
     */
    200: AnalyticsSummary;
};

export type GetApiAgentsByAgentIdAnalyticsSummaryResponse = GetApiAgentsByAgentIdAnalyticsSummaryResponses[keyof GetApiAgentsByAgentIdAnalyticsSummaryResponses];

export type GetApiAgentsByAgentIdAnalyticsTransactionsData = {
    body?: never;
    path: {
        agentId: string;
    };
    query?: {
        /**
         * Time window in hours (default: all time)
         */
        windowHours?: number;
        /**
         * Filter by payment direction
         */
        direction?: 'incoming' | 'outgoing';
    };
    url: '/api/agents/{agentId}/analytics/transactions';
};

export type GetApiAgentsByAgentIdAnalyticsTransactionsErrors = {
    /**
     * Analytics not available (payments not enabled)
     */
    400: _Error;
    /**
     * Agent not found
     */
    404: _Error;
};

export type GetApiAgentsByAgentIdAnalyticsTransactionsError = GetApiAgentsByAgentIdAnalyticsTransactionsErrors[keyof GetApiAgentsByAgentIdAnalyticsTransactionsErrors];

export type GetApiAgentsByAgentIdAnalyticsTransactionsResponses = {
    /**
     * List of transactions
     */
    200: Array<Transaction>;
};

export type GetApiAgentsByAgentIdAnalyticsTransactionsResponse = GetApiAgentsByAgentIdAnalyticsTransactionsResponses[keyof GetApiAgentsByAgentIdAnalyticsTransactionsResponses];

export type GetApiAgentsByAgentIdAnalyticsExportCsvData = {
    body?: never;
    path: {
        agentId: string;
    };
    query?: {
        /**
         * Time window in hours (default: all time)
         */
        windowHours?: number;
        /**
         * Filter by payment direction
         */
        direction?: 'incoming' | 'outgoing';
    };
    url: '/api/agents/{agentId}/analytics/export/csv';
};

export type GetApiAgentsByAgentIdAnalyticsExportCsvErrors = {
    /**
     * Analytics not available (payments not enabled)
     */
    400: _Error;
    /**
     * Agent not found
     */
    404: _Error;
};

export type GetApiAgentsByAgentIdAnalyticsExportCsvError = GetApiAgentsByAgentIdAnalyticsExportCsvErrors[keyof GetApiAgentsByAgentIdAnalyticsExportCsvErrors];

export type GetApiAgentsByAgentIdAnalyticsExportCsvResponses = {
    /**
     * CSV export
     */
    200: string;
};

export type GetApiAgentsByAgentIdAnalyticsExportCsvResponse = GetApiAgentsByAgentIdAnalyticsExportCsvResponses[keyof GetApiAgentsByAgentIdAnalyticsExportCsvResponses];

export type GetApiAgentsByAgentIdAnalyticsExportJsonData = {
    body?: never;
    path: {
        agentId: string;
    };
    query?: {
        /**
         * Time window in hours (default: all time)
         */
        windowHours?: number;
        /**
         * Filter by payment direction
         */
        direction?: 'incoming' | 'outgoing';
    };
    url: '/api/agents/{agentId}/analytics/export/json';
};

export type GetApiAgentsByAgentIdAnalyticsExportJsonErrors = {
    /**
     * Analytics not available (payments not enabled)
     */
    400: _Error;
    /**
     * Agent not found
     */
    404: _Error;
};

export type GetApiAgentsByAgentIdAnalyticsExportJsonError = GetApiAgentsByAgentIdAnalyticsExportJsonErrors[keyof GetApiAgentsByAgentIdAnalyticsExportJsonErrors];

export type GetApiAgentsByAgentIdAnalyticsExportJsonResponses = {
    /**
     * JSON export
     */
    200: {
        summary: AnalyticsSummary;
        transactions: Array<Transaction>;
    };
};

export type GetApiAgentsByAgentIdAnalyticsExportJsonResponse = GetApiAgentsByAgentIdAnalyticsExportJsonResponses[keyof GetApiAgentsByAgentIdAnalyticsExportJsonResponses];

export type PostApiAgentsByAgentIdIdentityRetryData = {
    body?: never;
    path: {
        agentId: string;
    };
    query?: never;
    url: '/api/agents/{agentId}/identity/retry';
};

export type PostApiAgentsByAgentIdIdentityRetryErrors = {
    /**
     * Identity not configured or wallet not available
     */
    400: _Error;
    /**
     * Agent not found
     */
    404: _Error;
};

export type PostApiAgentsByAgentIdIdentityRetryError = PostApiAgentsByAgentIdIdentityRetryErrors[keyof PostApiAgentsByAgentIdIdentityRetryErrors];

export type PostApiAgentsByAgentIdIdentityRetryResponses = {
    /**
     * Identity registration result
     */
    200: IdentityRegistrationResult;
};

export type PostApiAgentsByAgentIdIdentityRetryResponse = PostApiAgentsByAgentIdIdentityRetryResponses[keyof PostApiAgentsByAgentIdIdentityRetryResponses];

export type PostApiAgentsByAgentIdIdentityUpdateData = {
    body?: UpdateIdentityMetadataRequest;
    path: {
        agentId: string;
    };
    query?: never;
    url: '/api/agents/{agentId}/identity/update';
};

export type PostApiAgentsByAgentIdIdentityUpdateErrors = {
    /**
     * Agent not found
     */
    404: _Error;
};

export type PostApiAgentsByAgentIdIdentityUpdateError = PostApiAgentsByAgentIdIdentityUpdateErrors[keyof PostApiAgentsByAgentIdIdentityUpdateErrors];

export type PostApiAgentsByAgentIdIdentityUpdateResponses = {
    /**
     * Identity metadata updated
     */
    200: IdentityRegistrationResult;
};

export type PostApiAgentsByAgentIdIdentityUpdateResponse = PostApiAgentsByAgentIdIdentityUpdateResponses[keyof PostApiAgentsByAgentIdIdentityUpdateResponses];

export type GetHealthData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/health';
};

export type GetHealthResponses = {
    /**
     * Service is healthy
     */
    200: Health;
};

export type GetHealthResponse = GetHealthResponses[keyof GetHealthResponses];

export type GetHealthRedisData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/health/redis';
};

export type GetHealthRedisErrors = {
    /**
     * Redis is unavailable
     */
    503: RedisHealth;
};

export type GetHealthRedisError = GetHealthRedisErrors[keyof GetHealthRedisErrors];

export type GetHealthRedisResponses = {
    /**
     * Redis health status
     */
    200: RedisHealth;
};

export type GetHealthRedisResponse = GetHealthRedisResponses[keyof GetHealthRedisResponses];

export type GetApiStatsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/stats';
};

export type GetApiStatsErrors = {
    /**
     * Internal server error
     */
    500: _Error;
};

export type GetApiStatsError = GetApiStatsErrors[keyof GetApiStatsErrors];

export type GetApiStatsResponses = {
    /**
     * Network statistics
     */
    200: NetworkStats;
};

export type GetApiStatsResponse = GetApiStatsResponses[keyof GetApiStatsResponses];

export type GetApiRankingsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Metric to rank by
         */
        metric?: 'calls' | 'revenue' | 'errors' | 'latency' | 'trending';
        /**
         * Time window for ranking
         */
        window?: '1m' | '5m' | '15m' | '1h' | '24h' | '7d';
        /**
         * Ranking scope
         */
        scope?: 'global' | 'owner' | 'agent';
        /**
         * Required for owner/agent scope
         */
        scopeId?: string;
        /**
         * Maximum entries to return
         */
        limit?: number;
        /**
         * Offset for pagination
         */
        offset?: number | null;
    };
    url: '/api/rankings';
};

export type GetApiRankingsErrors = {
    /**
     * Invalid query parameters
     */
    400: _Error;
    /**
     * Ranking service unavailable
     */
    503: _Error;
};

export type GetApiRankingsError = GetApiRankingsErrors[keyof GetApiRankingsErrors];

export type GetApiRankingsResponses = {
    /**
     * Ranking results
     */
    200: RankingResult;
};

export type GetApiRankingsResponse = GetApiRankingsResponses[keyof GetApiRankingsResponses];

export type GetApiRankingsStreamData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Metric to rank by
         */
        metric?: 'calls' | 'revenue' | 'errors' | 'latency' | 'trending';
        /**
         * Time window for ranking
         */
        window?: '1m' | '5m' | '15m' | '1h' | '24h' | '7d';
        /**
         * Ranking scope
         */
        scope?: 'global' | 'owner' | 'agent';
        /**
         * Required for owner/agent scope
         */
        scopeId?: string;
        /**
         * Include real-time invocation events in the stream
         */
        includeInvocations?: boolean | null;
        /**
         * Heartbeat interval in milliseconds (1-60 seconds)
         */
        heartbeatMs?: number;
    };
    url: '/api/rankings/stream';
};

export type GetApiRankingsStreamErrors = {
    /**
     * Ranking service unavailable
     */
    503: _Error;
};

export type GetApiRankingsStreamError = GetApiRankingsStreamErrors[keyof GetApiRankingsStreamErrors];

export type GetApiRankingsStreamResponses = {
    /**
     * SSE event stream with ranking updates, invocations, and heartbeats
     */
    200: string;
};

export type GetApiRankingsStreamResponse = GetApiRankingsStreamResponses[keyof GetApiRankingsStreamResponses];

export type GetApiInvocationsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter by agent ID
         */
        agentId?: string;
        /**
         * Filter by entrypoint key
         */
        entrypointKey?: string;
        /**
         * Filter by status
         */
        status?: 'success' | 'error' | 'timeout';
        /**
         * Start of time range (inclusive)
         */
        startDate?: string;
        /**
         * End of time range (inclusive)
         */
        endDate?: string;
        /**
         * Number of items to skip
         */
        offset?: number | null;
        /**
         * Maximum items to return
         */
        limit?: number;
    };
    url: '/api/invocations';
};

export type GetApiInvocationsErrors = {
    /**
     * Invalid query parameters
     */
    400: _Error;
};

export type GetApiInvocationsError = GetApiInvocationsErrors[keyof GetApiInvocationsErrors];

export type GetApiInvocationsResponses = {
    /**
     * Paginated list of invocations
     */
    200: InvocationListResult;
};

export type GetApiInvocationsResponse = GetApiInvocationsResponses[keyof GetApiInvocationsResponses];

export type GetApiInvocationsStatsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter by agent ID
         */
        agentId?: string;
        /**
         * Filter by entrypoint key
         */
        entrypointKey?: string;
        /**
         * Filter by status
         */
        status?: 'success' | 'error' | 'timeout';
        /**
         * Start of time range (inclusive)
         */
        startDate?: string;
        /**
         * End of time range (inclusive)
         */
        endDate?: string;
    };
    url: '/api/invocations/stats';
};

export type GetApiInvocationsStatsErrors = {
    /**
     * Invalid query parameters
     */
    400: _Error;
};

export type GetApiInvocationsStatsError = GetApiInvocationsStatsErrors[keyof GetApiInvocationsStatsErrors];

export type GetApiInvocationsStatsResponses = {
    /**
     * Aggregate statistics
     */
    200: InvocationStats;
};

export type GetApiInvocationsStatsResponse = GetApiInvocationsStatsResponses[keyof GetApiInvocationsStatsResponses];

export type GetApiInvocationsTimeseriesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter by agent ID
         */
        agentId?: string;
        /**
         * Filter by entrypoint key
         */
        entrypointKey?: string;
        /**
         * Filter by status
         */
        status?: 'success' | 'error' | 'timeout';
        /**
         * Start of time range (inclusive)
         */
        startDate?: string;
        /**
         * End of time range (inclusive)
         */
        endDate?: string;
        /**
         * Time bucket size for aggregation
         */
        bucket?: 'hour' | 'day' | 'week' | 'month';
    };
    url: '/api/invocations/timeseries';
};

export type GetApiInvocationsTimeseriesErrors = {
    /**
     * Invalid query parameters
     */
    400: _Error;
};

export type GetApiInvocationsTimeseriesError = GetApiInvocationsTimeseriesErrors[keyof GetApiInvocationsTimeseriesErrors];

export type GetApiInvocationsTimeseriesResponses = {
    /**
     * Time series data points
     */
    200: InvocationTimeSeriesResult;
};

export type GetApiInvocationsTimeseriesResponse = GetApiInvocationsTimeseriesResponses[keyof GetApiInvocationsTimeseriesResponses];

export type GetApiInvocationsByInvocationIdData = {
    body?: never;
    path: {
        invocationId: string;
    };
    query?: never;
    url: '/api/invocations/{invocationId}';
};

export type GetApiInvocationsByInvocationIdErrors = {
    /**
     * Invocation not found
     */
    404: _Error;
};

export type GetApiInvocationsByInvocationIdError = GetApiInvocationsByInvocationIdErrors[keyof GetApiInvocationsByInvocationIdErrors];

export type GetApiInvocationsByInvocationIdResponses = {
    /**
     * Invocation details
     */
    200: Invocation;
};

export type GetApiInvocationsByInvocationIdResponse = GetApiInvocationsByInvocationIdResponses[keyof GetApiInvocationsByInvocationIdResponses];
